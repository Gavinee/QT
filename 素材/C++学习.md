#C++ 的一些用法的归纳与总结

##拷贝构造函数、赋值构造函数
**传入参数、返回值、列表初始化需要用到拷贝构造函数**
**赋值构造函数用于需要将对象进行赋值**

### 拷贝构造函数
在《C++ Primer 第五版》中第441面，有对于拷贝初始化的发生情况
>    
    拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生:
    · 将一个对象作为实参传递给一个非引用类型的形参                  传入参数
    · 从一个返回类型为非引用类型的函数返回一个对象                  返回值
    · 用花括号列表初始化一个数组中的一个元素或一个聚合类中的成员     列表初始化


>   在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。
    拷贝构造函数被用来初始化非引用类类型参数，__这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环__。

>   拷贝构造函数的限制
    如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了:
        vector<int> v1(10);         //正确
        vector<int > v2 = 10;       //错误
        void f(vector<int>);        //f的参数进行拷贝初始化
        f(10);                      //错误，不能用一个explicit的构造函数拷贝一个实参
        f(vector<int>(10));         //正确：从一个int直接构造一个临时vector
    直接初始化v1是合法的，但看起来与之等价的拷贝初始化v2则是错误的，因为vector的接受单个参数的构造函数是explicit的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用一个explicit构造函数，就必须显示地使用，想此代码中最后一行那样。


### 拷贝赋值运算符
重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。类似于任何其他函数，
重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象最为显示参数传递。


### 析构函数
· 变量在离开其作用域时被销毁
· 当一个对象被销毁时，其成员被销毁
· 容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
· 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
· 对于临时对象，当创建它的完整表达式结束时被销毁









































